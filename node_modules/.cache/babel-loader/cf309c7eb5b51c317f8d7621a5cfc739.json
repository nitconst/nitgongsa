{"ast":null,"code":"(function () {\n  var debug = false;\n  var root = this;\n\n  var EXIF = function (obj) {\n    if (obj instanceof EXIF) return obj;\n    if (!(this instanceof EXIF)) return new EXIF(obj);\n    this.EXIFwrapped = obj;\n  };\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = EXIF;\n    }\n\n    exports.EXIF = EXIF;\n  } else {\n    root.EXIF = EXIF;\n  }\n\n  var ExifTags = EXIF.Tags = {\n    // version tags\n    0x9000: \"ExifVersion\",\n    // EXIF version\n    0xA000: \"FlashpixVersion\",\n    // Flashpix format version\n    // colorspace tags\n    0xA001: \"ColorSpace\",\n    // Color space information tag\n    // image configuration\n    0xA002: \"PixelXDimension\",\n    // Valid width of meaningful image\n    0xA003: \"PixelYDimension\",\n    // Valid height of meaningful image\n    0x9101: \"ComponentsConfiguration\",\n    // Information about channels\n    0x9102: \"CompressedBitsPerPixel\",\n    // Compressed bits per pixel\n    // user information\n    0x927C: \"MakerNote\",\n    // Any desired information written by the manufacturer\n    0x9286: \"UserComment\",\n    // Comments by user\n    // related file\n    0xA004: \"RelatedSoundFile\",\n    // Name of related sound file\n    // date and time\n    0x9003: \"DateTimeOriginal\",\n    // Date and time when the original image was generated\n    0x9004: \"DateTimeDigitized\",\n    // Date and time when the image was stored digitally\n    0x9290: \"SubsecTime\",\n    // Fractions of seconds for DateTime\n    0x9291: \"SubsecTimeOriginal\",\n    // Fractions of seconds for DateTimeOriginal\n    0x9292: \"SubsecTimeDigitized\",\n    // Fractions of seconds for DateTimeDigitized\n    // picture-taking conditions\n    0x829A: \"ExposureTime\",\n    // Exposure time (in seconds)\n    0x829D: \"FNumber\",\n    // F number\n    0x8822: \"ExposureProgram\",\n    // Exposure program\n    0x8824: \"SpectralSensitivity\",\n    // Spectral sensitivity\n    0x8827: \"ISOSpeedRatings\",\n    // ISO speed rating\n    0x8828: \"OECF\",\n    // Optoelectric conversion factor\n    0x9201: \"ShutterSpeedValue\",\n    // Shutter speed\n    0x9202: \"ApertureValue\",\n    // Lens aperture\n    0x9203: \"BrightnessValue\",\n    // Value of brightness\n    0x9204: \"ExposureBias\",\n    // Exposure bias\n    0x9205: \"MaxApertureValue\",\n    // Smallest F number of lens\n    0x9206: \"SubjectDistance\",\n    // Distance to subject in meters\n    0x9207: \"MeteringMode\",\n    // Metering mode\n    0x9208: \"LightSource\",\n    // Kind of light source\n    0x9209: \"Flash\",\n    // Flash status\n    0x9214: \"SubjectArea\",\n    // Location and area of main subject\n    0x920A: \"FocalLength\",\n    // Focal length of the lens in mm\n    0xA20B: \"FlashEnergy\",\n    // Strobe energy in BCPS\n    0xA20C: \"SpatialFrequencyResponse\",\n    //\n    0xA20E: \"FocalPlaneXResolution\",\n    // Number of pixels in width direction per FocalPlaneResolutionUnit\n    0xA20F: \"FocalPlaneYResolution\",\n    // Number of pixels in height direction per FocalPlaneResolutionUnit\n    0xA210: \"FocalPlaneResolutionUnit\",\n    // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution\n    0xA214: \"SubjectLocation\",\n    // Location of subject in image\n    0xA215: \"ExposureIndex\",\n    // Exposure index selected on camera\n    0xA217: \"SensingMethod\",\n    // Image sensor type\n    0xA300: \"FileSource\",\n    // Image source (3 == DSC)\n    0xA301: \"SceneType\",\n    // Scene type (1 == directly photographed)\n    0xA302: \"CFAPattern\",\n    // Color filter array geometric pattern\n    0xA401: \"CustomRendered\",\n    // Special processing\n    0xA402: \"ExposureMode\",\n    // Exposure mode\n    0xA403: \"WhiteBalance\",\n    // 1 = auto white balance, 2 = manual\n    0xA404: \"DigitalZoomRation\",\n    // Digital zoom ratio\n    0xA405: \"FocalLengthIn35mmFilm\",\n    // Equivalent foacl length assuming 35mm film camera (in mm)\n    0xA406: \"SceneCaptureType\",\n    // Type of scene\n    0xA407: \"GainControl\",\n    // Degree of overall image gain adjustment\n    0xA408: \"Contrast\",\n    // Direction of contrast processing applied by camera\n    0xA409: \"Saturation\",\n    // Direction of saturation processing applied by camera\n    0xA40A: \"Sharpness\",\n    // Direction of sharpness processing applied by camera\n    0xA40B: \"DeviceSettingDescription\",\n    //\n    0xA40C: \"SubjectDistanceRange\",\n    // Distance to subject\n    // other tags\n    0xA005: \"InteroperabilityIFDPointer\",\n    0xA420: \"ImageUniqueID\" // Identifier assigned uniquely to each image\n\n  };\n  var TiffTags = EXIF.TiffTags = {\n    0x0100: \"ImageWidth\",\n    0x0101: \"ImageHeight\",\n    0x8769: \"ExifIFDPointer\",\n    0x8825: \"GPSInfoIFDPointer\",\n    0xA005: \"InteroperabilityIFDPointer\",\n    0x0102: \"BitsPerSample\",\n    0x0103: \"Compression\",\n    0x0106: \"PhotometricInterpretation\",\n    0x0112: \"Orientation\",\n    0x0115: \"SamplesPerPixel\",\n    0x011C: \"PlanarConfiguration\",\n    0x0212: \"YCbCrSubSampling\",\n    0x0213: \"YCbCrPositioning\",\n    0x011A: \"XResolution\",\n    0x011B: \"YResolution\",\n    0x0128: \"ResolutionUnit\",\n    0x0111: \"StripOffsets\",\n    0x0116: \"RowsPerStrip\",\n    0x0117: \"StripByteCounts\",\n    0x0201: \"JPEGInterchangeFormat\",\n    0x0202: \"JPEGInterchangeFormatLength\",\n    0x012D: \"TransferFunction\",\n    0x013E: \"WhitePoint\",\n    0x013F: \"PrimaryChromaticities\",\n    0x0211: \"YCbCrCoefficients\",\n    0x0214: \"ReferenceBlackWhite\",\n    0x0132: \"DateTime\",\n    0x010E: \"ImageDescription\",\n    0x010F: \"Make\",\n    0x0110: \"Model\",\n    0x0131: \"Software\",\n    0x013B: \"Artist\",\n    0x8298: \"Copyright\"\n  };\n  var GPSTags = EXIF.GPSTags = {\n    0x0000: \"GPSVersionID\",\n    0x0001: \"GPSLatitudeRef\",\n    0x0002: \"GPSLatitude\",\n    0x0003: \"GPSLongitudeRef\",\n    0x0004: \"GPSLongitude\",\n    0x0005: \"GPSAltitudeRef\",\n    0x0006: \"GPSAltitude\",\n    0x0007: \"GPSTimeStamp\",\n    0x0008: \"GPSSatellites\",\n    0x0009: \"GPSStatus\",\n    0x000A: \"GPSMeasureMode\",\n    0x000B: \"GPSDOP\",\n    0x000C: \"GPSSpeedRef\",\n    0x000D: \"GPSSpeed\",\n    0x000E: \"GPSTrackRef\",\n    0x000F: \"GPSTrack\",\n    0x0010: \"GPSImgDirectionRef\",\n    0x0011: \"GPSImgDirection\",\n    0x0012: \"GPSMapDatum\",\n    0x0013: \"GPSDestLatitudeRef\",\n    0x0014: \"GPSDestLatitude\",\n    0x0015: \"GPSDestLongitudeRef\",\n    0x0016: \"GPSDestLongitude\",\n    0x0017: \"GPSDestBearingRef\",\n    0x0018: \"GPSDestBearing\",\n    0x0019: \"GPSDestDistanceRef\",\n    0x001A: \"GPSDestDistance\",\n    0x001B: \"GPSProcessingMethod\",\n    0x001C: \"GPSAreaInformation\",\n    0x001D: \"GPSDateStamp\",\n    0x001E: \"GPSDifferential\"\n  }; // EXIF 2.3 Spec\n\n  var IFD1Tags = EXIF.IFD1Tags = {\n    0x0100: \"ImageWidth\",\n    0x0101: \"ImageHeight\",\n    0x0102: \"BitsPerSample\",\n    0x0103: \"Compression\",\n    0x0106: \"PhotometricInterpretation\",\n    0x0111: \"StripOffsets\",\n    0x0112: \"Orientation\",\n    0x0115: \"SamplesPerPixel\",\n    0x0116: \"RowsPerStrip\",\n    0x0117: \"StripByteCounts\",\n    0x011A: \"XResolution\",\n    0x011B: \"YResolution\",\n    0x011C: \"PlanarConfiguration\",\n    0x0128: \"ResolutionUnit\",\n    0x0201: \"JpegIFOffset\",\n    // When image format is JPEG, this value show offset to JPEG data stored.(aka \"ThumbnailOffset\" or \"JPEGInterchangeFormat\")\n    0x0202: \"JpegIFByteCount\",\n    // When image format is JPEG, this value shows data size of JPEG image (aka \"ThumbnailLength\" or \"JPEGInterchangeFormatLength\")\n    0x0211: \"YCbCrCoefficients\",\n    0x0212: \"YCbCrSubSampling\",\n    0x0213: \"YCbCrPositioning\",\n    0x0214: \"ReferenceBlackWhite\"\n  };\n  var StringValues = EXIF.StringValues = {\n    ExposureProgram: {\n      0: \"Not defined\",\n      1: \"Manual\",\n      2: \"Normal program\",\n      3: \"Aperture priority\",\n      4: \"Shutter priority\",\n      5: \"Creative program\",\n      6: \"Action program\",\n      7: \"Portrait mode\",\n      8: \"Landscape mode\"\n    },\n    MeteringMode: {\n      0: \"Unknown\",\n      1: \"Average\",\n      2: \"CenterWeightedAverage\",\n      3: \"Spot\",\n      4: \"MultiSpot\",\n      5: \"Pattern\",\n      6: \"Partial\",\n      255: \"Other\"\n    },\n    LightSource: {\n      0: \"Unknown\",\n      1: \"Daylight\",\n      2: \"Fluorescent\",\n      3: \"Tungsten (incandescent light)\",\n      4: \"Flash\",\n      9: \"Fine weather\",\n      10: \"Cloudy weather\",\n      11: \"Shade\",\n      12: \"Daylight fluorescent (D 5700 - 7100K)\",\n      13: \"Day white fluorescent (N 4600 - 5400K)\",\n      14: \"Cool white fluorescent (W 3900 - 4500K)\",\n      15: \"White fluorescent (WW 3200 - 3700K)\",\n      17: \"Standard light A\",\n      18: \"Standard light B\",\n      19: \"Standard light C\",\n      20: \"D55\",\n      21: \"D65\",\n      22: \"D75\",\n      23: \"D50\",\n      24: \"ISO studio tungsten\",\n      255: \"Other\"\n    },\n    Flash: {\n      0x0000: \"Flash did not fire\",\n      0x0001: \"Flash fired\",\n      0x0005: \"Strobe return light not detected\",\n      0x0007: \"Strobe return light detected\",\n      0x0009: \"Flash fired, compulsory flash mode\",\n      0x000D: \"Flash fired, compulsory flash mode, return light not detected\",\n      0x000F: \"Flash fired, compulsory flash mode, return light detected\",\n      0x0010: \"Flash did not fire, compulsory flash mode\",\n      0x0018: \"Flash did not fire, auto mode\",\n      0x0019: \"Flash fired, auto mode\",\n      0x001D: \"Flash fired, auto mode, return light not detected\",\n      0x001F: \"Flash fired, auto mode, return light detected\",\n      0x0020: \"No flash function\",\n      0x0041: \"Flash fired, red-eye reduction mode\",\n      0x0045: \"Flash fired, red-eye reduction mode, return light not detected\",\n      0x0047: \"Flash fired, red-eye reduction mode, return light detected\",\n      0x0049: \"Flash fired, compulsory flash mode, red-eye reduction mode\",\n      0x004D: \"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected\",\n      0x004F: \"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected\",\n      0x0059: \"Flash fired, auto mode, red-eye reduction mode\",\n      0x005D: \"Flash fired, auto mode, return light not detected, red-eye reduction mode\",\n      0x005F: \"Flash fired, auto mode, return light detected, red-eye reduction mode\"\n    },\n    SensingMethod: {\n      1: \"Not defined\",\n      2: \"One-chip color area sensor\",\n      3: \"Two-chip color area sensor\",\n      4: \"Three-chip color area sensor\",\n      5: \"Color sequential area sensor\",\n      7: \"Trilinear sensor\",\n      8: \"Color sequential linear sensor\"\n    },\n    SceneCaptureType: {\n      0: \"Standard\",\n      1: \"Landscape\",\n      2: \"Portrait\",\n      3: \"Night scene\"\n    },\n    SceneType: {\n      1: \"Directly photographed\"\n    },\n    CustomRendered: {\n      0: \"Normal process\",\n      1: \"Custom process\"\n    },\n    WhiteBalance: {\n      0: \"Auto white balance\",\n      1: \"Manual white balance\"\n    },\n    GainControl: {\n      0: \"None\",\n      1: \"Low gain up\",\n      2: \"High gain up\",\n      3: \"Low gain down\",\n      4: \"High gain down\"\n    },\n    Contrast: {\n      0: \"Normal\",\n      1: \"Soft\",\n      2: \"Hard\"\n    },\n    Saturation: {\n      0: \"Normal\",\n      1: \"Low saturation\",\n      2: \"High saturation\"\n    },\n    Sharpness: {\n      0: \"Normal\",\n      1: \"Soft\",\n      2: \"Hard\"\n    },\n    SubjectDistanceRange: {\n      0: \"Unknown\",\n      1: \"Macro\",\n      2: \"Close view\",\n      3: \"Distant view\"\n    },\n    FileSource: {\n      3: \"DSC\"\n    },\n    Components: {\n      0: \"\",\n      1: \"Y\",\n      2: \"Cb\",\n      3: \"Cr\",\n      4: \"R\",\n      5: \"G\",\n      6: \"B\"\n    }\n  };\n\n  function addEvent(element, event, handler) {\n    if (element.addEventListener) {\n      element.addEventListener(event, handler, false);\n    } else if (element.attachEvent) {\n      element.attachEvent(\"on\" + event, handler);\n    }\n  }\n\n  function imageHasData(img) {\n    return !!img.exifdata;\n  }\n\n  function base64ToArrayBuffer(base64, contentType) {\n    contentType = contentType || base64.match(/^data\\:([^\\;]+)\\;base64,/mi)[1] || ''; // e.g. 'data:image/jpeg;base64,...' => 'image/jpeg'\n\n    base64 = base64.replace(/^data\\:([^\\;]+)\\;base64,/gmi, '');\n    var binary = atob(base64);\n    var len = binary.length;\n    var buffer = new ArrayBuffer(len);\n    var view = new Uint8Array(buffer);\n\n    for (var i = 0; i < len; i++) {\n      view[i] = binary.charCodeAt(i);\n    }\n\n    return buffer;\n  }\n\n  function objectURLToBlob(url, callback) {\n    var http = new XMLHttpRequest();\n    http.open(\"GET\", url, true);\n    http.responseType = \"blob\";\n\n    http.onload = function (e) {\n      if (this.status == 200 || this.status === 0) {\n        callback(this.response);\n      }\n    };\n\n    http.send();\n  }\n\n  function getImageData(img, callback) {\n    function handleBinaryFile(binFile) {\n      var data = findEXIFinJPEG(binFile);\n      img.exifdata = data || {};\n      var iptcdata = findIPTCinJPEG(binFile);\n      img.iptcdata = iptcdata || {};\n\n      if (EXIF.isXmpEnabled) {\n        var xmpdata = findXMPinJPEG(binFile);\n        img.xmpdata = xmpdata || {};\n      }\n\n      if (callback) {\n        callback.call(img);\n      }\n    }\n\n    if (img.src) {\n      if (/^data\\:/i.test(img.src)) {\n        // Data URI\n        var arrayBuffer = base64ToArrayBuffer(img.src);\n        handleBinaryFile(arrayBuffer);\n      } else if (/^blob\\:/i.test(img.src)) {\n        // Object URL\n        var fileReader = new FileReader();\n\n        fileReader.onload = function (e) {\n          handleBinaryFile(e.target.result);\n        };\n\n        objectURLToBlob(img.src, function (blob) {\n          fileReader.readAsArrayBuffer(blob);\n        });\n      } else {\n        var http = new XMLHttpRequest();\n\n        http.onload = function () {\n          if (this.status == 200 || this.status === 0) {\n            handleBinaryFile(http.response);\n          } else {\n            throw \"Could not load image\";\n          }\n\n          http = null;\n        };\n\n        http.open(\"GET\", img.src, true);\n        http.responseType = \"arraybuffer\";\n        http.send(null);\n      }\n    } else if (self.FileReader && (img instanceof self.Blob || img instanceof self.File)) {\n      var fileReader = new FileReader();\n\n      fileReader.onload = function (e) {\n        if (debug) console.log(\"Got file of length \" + e.target.result.byteLength);\n        handleBinaryFile(e.target.result);\n      };\n\n      fileReader.readAsArrayBuffer(img);\n    }\n  }\n\n  function findEXIFinJPEG(file) {\n    var dataView = new DataView(file);\n    if (debug) console.log(\"Got file of length \" + file.byteLength);\n\n    if (dataView.getUint8(0) != 0xFF || dataView.getUint8(1) != 0xD8) {\n      if (debug) console.log(\"Not a valid JPEG\");\n      return false; // not a valid jpeg\n    }\n\n    var offset = 2,\n        length = file.byteLength,\n        marker;\n\n    while (offset < length) {\n      if (dataView.getUint8(offset) != 0xFF) {\n        if (debug) console.log(\"Not a valid marker at offset \" + offset + \", found: \" + dataView.getUint8(offset));\n        return false; // not a valid marker, something is wrong\n      }\n\n      marker = dataView.getUint8(offset + 1);\n      if (debug) console.log(marker); // we could implement handling for other markers here,\n      // but we're only looking for 0xFFE1 for EXIF data\n\n      if (marker == 225) {\n        if (debug) console.log(\"Found 0xFFE1 marker\");\n        return readEXIFData(dataView, offset + 4, dataView.getUint16(offset + 2) - 2); // offset += 2 + file.getShortAt(offset+2, true);\n      } else {\n        offset += 2 + dataView.getUint16(offset + 2);\n      }\n    }\n  }\n\n  function findIPTCinJPEG(file) {\n    var dataView = new DataView(file);\n    if (debug) console.log(\"Got file of length \" + file.byteLength);\n\n    if (dataView.getUint8(0) != 0xFF || dataView.getUint8(1) != 0xD8) {\n      if (debug) console.log(\"Not a valid JPEG\");\n      return false; // not a valid jpeg\n    }\n\n    var offset = 2,\n        length = file.byteLength;\n\n    var isFieldSegmentStart = function (dataView, offset) {\n      return dataView.getUint8(offset) === 0x38 && dataView.getUint8(offset + 1) === 0x42 && dataView.getUint8(offset + 2) === 0x49 && dataView.getUint8(offset + 3) === 0x4D && dataView.getUint8(offset + 4) === 0x04 && dataView.getUint8(offset + 5) === 0x04;\n    };\n\n    while (offset < length) {\n      if (isFieldSegmentStart(dataView, offset)) {\n        // Get the length of the name header (which is padded to an even number of bytes)\n        var nameHeaderLength = dataView.getUint8(offset + 7);\n        if (nameHeaderLength % 2 !== 0) nameHeaderLength += 1; // Check for pre photoshop 6 format\n\n        if (nameHeaderLength === 0) {\n          // Always 4\n          nameHeaderLength = 4;\n        }\n\n        var startOffset = offset + 8 + nameHeaderLength;\n        var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);\n        return readIPTCData(file, startOffset, sectionLength);\n        break;\n      } // Not the marker, continue searching\n\n\n      offset++;\n    }\n  }\n\n  var IptcFieldMap = {\n    0x78: 'caption',\n    0x6E: 'credit',\n    0x19: 'keywords',\n    0x37: 'dateCreated',\n    0x50: 'byline',\n    0x55: 'bylineTitle',\n    0x7A: 'captionWriter',\n    0x69: 'headline',\n    0x74: 'copyright',\n    0x0F: 'category'\n  };\n\n  function readIPTCData(file, startOffset, sectionLength) {\n    var dataView = new DataView(file);\n    var data = {};\n    var fieldValue, fieldName, dataSize, segmentType, segmentSize;\n    var segmentStartPos = startOffset;\n\n    while (segmentStartPos < startOffset + sectionLength) {\n      if (dataView.getUint8(segmentStartPos) === 0x1C && dataView.getUint8(segmentStartPos + 1) === 0x02) {\n        segmentType = dataView.getUint8(segmentStartPos + 2);\n\n        if (segmentType in IptcFieldMap) {\n          dataSize = dataView.getInt16(segmentStartPos + 3);\n          segmentSize = dataSize + 5;\n          fieldName = IptcFieldMap[segmentType];\n          fieldValue = getStringFromDB(dataView, segmentStartPos + 5, dataSize); // Check if we already stored a value with this name\n\n          if (data.hasOwnProperty(fieldName)) {\n            // Value already stored with this name, create multivalue field\n            if (data[fieldName] instanceof Array) {\n              data[fieldName].push(fieldValue);\n            } else {\n              data[fieldName] = [data[fieldName], fieldValue];\n            }\n          } else {\n            data[fieldName] = fieldValue;\n          }\n        }\n      }\n\n      segmentStartPos++;\n    }\n\n    return data;\n  }\n\n  function readTags(file, tiffStart, dirStart, strings, bigEnd) {\n    var entries = file.getUint16(dirStart, !bigEnd),\n        tags = {},\n        entryOffset,\n        tag,\n        i;\n\n    for (i = 0; i < entries; i++) {\n      entryOffset = dirStart + i * 12 + 2;\n      tag = strings[file.getUint16(entryOffset, !bigEnd)];\n      if (!tag && debug) console.log(\"Unknown tag: \" + file.getUint16(entryOffset, !bigEnd));\n      tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);\n    }\n\n    return tags;\n  }\n\n  function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {\n    var type = file.getUint16(entryOffset + 2, !bigEnd),\n        numValues = file.getUint32(entryOffset + 4, !bigEnd),\n        valueOffset = file.getUint32(entryOffset + 8, !bigEnd) + tiffStart,\n        offset,\n        vals,\n        val,\n        n,\n        numerator,\n        denominator;\n\n    switch (type) {\n      case 1: // byte, 8-bit unsigned int\n\n      case 7:\n        // undefined, 8-bit byte, value depending on field\n        if (numValues == 1) {\n          return file.getUint8(entryOffset + 8, !bigEnd);\n        } else {\n          offset = numValues > 4 ? valueOffset : entryOffset + 8;\n          vals = [];\n\n          for (n = 0; n < numValues; n++) {\n            vals[n] = file.getUint8(offset + n);\n          }\n\n          return vals;\n        }\n\n      case 2:\n        // ascii, 8-bit byte\n        offset = numValues > 4 ? valueOffset : entryOffset + 8;\n        return getStringFromDB(file, offset, numValues - 1);\n\n      case 3:\n        // short, 16 bit int\n        if (numValues == 1) {\n          return file.getUint16(entryOffset + 8, !bigEnd);\n        } else {\n          offset = numValues > 2 ? valueOffset : entryOffset + 8;\n          vals = [];\n\n          for (n = 0; n < numValues; n++) {\n            vals[n] = file.getUint16(offset + 2 * n, !bigEnd);\n          }\n\n          return vals;\n        }\n\n      case 4:\n        // long, 32 bit int\n        if (numValues == 1) {\n          return file.getUint32(entryOffset + 8, !bigEnd);\n        } else {\n          vals = [];\n\n          for (n = 0; n < numValues; n++) {\n            vals[n] = file.getUint32(valueOffset + 4 * n, !bigEnd);\n          }\n\n          return vals;\n        }\n\n      case 5:\n        // rational = two long values, first is numerator, second is denominator\n        if (numValues == 1) {\n          numerator = file.getUint32(valueOffset, !bigEnd);\n          denominator = file.getUint32(valueOffset + 4, !bigEnd);\n          val = new Number(numerator / denominator);\n          val.numerator = numerator;\n          val.denominator = denominator;\n          return val;\n        } else {\n          vals = [];\n\n          for (n = 0; n < numValues; n++) {\n            numerator = file.getUint32(valueOffset + 8 * n, !bigEnd);\n            denominator = file.getUint32(valueOffset + 4 + 8 * n, !bigEnd);\n            vals[n] = new Number(numerator / denominator);\n            vals[n].numerator = numerator;\n            vals[n].denominator = denominator;\n          }\n\n          return vals;\n        }\n\n      case 9:\n        // slong, 32 bit signed int\n        if (numValues == 1) {\n          return file.getInt32(entryOffset + 8, !bigEnd);\n        } else {\n          vals = [];\n\n          for (n = 0; n < numValues; n++) {\n            vals[n] = file.getInt32(valueOffset + 4 * n, !bigEnd);\n          }\n\n          return vals;\n        }\n\n      case 10:\n        // signed rational, two slongs, first is numerator, second is denominator\n        if (numValues == 1) {\n          return file.getInt32(valueOffset, !bigEnd) / file.getInt32(valueOffset + 4, !bigEnd);\n        } else {\n          vals = [];\n\n          for (n = 0; n < numValues; n++) {\n            vals[n] = file.getInt32(valueOffset + 8 * n, !bigEnd) / file.getInt32(valueOffset + 4 + 8 * n, !bigEnd);\n          }\n\n          return vals;\n        }\n\n    }\n  }\n  /**\r\n  * Given an IFD (Image File Directory) start offset\r\n  * returns an offset to next IFD or 0 if it's the last IFD.\r\n  */\n\n\n  function getNextIFDOffset(dataView, dirStart, bigEnd) {\n    //the first 2bytes means the number of directory entries contains in this IFD\n    var entries = dataView.getUint16(dirStart, !bigEnd); // After last directory entry, there is a 4bytes of data,\n    // it means an offset to next IFD.\n    // If its value is '0x00000000', it means this is the last IFD and there is no linked IFD.\n\n    return dataView.getUint32(dirStart + 2 + entries * 12, !bigEnd); // each entry is 12 bytes long\n  }\n\n  function readThumbnailImage(dataView, tiffStart, firstIFDOffset, bigEnd) {\n    // get the IFD1 offset\n    var IFD1OffsetPointer = getNextIFDOffset(dataView, tiffStart + firstIFDOffset, bigEnd);\n\n    if (!IFD1OffsetPointer) {\n      // console.log('******** IFD1Offset is empty, image thumb not found ********');\n      return {};\n    } else if (IFD1OffsetPointer > dataView.byteLength) {\n      // this should not happen\n      // console.log('******** IFD1Offset is outside the bounds of the DataView ********');\n      return {};\n    } // console.log('*******  thumbnail IFD offset (IFD1) is: %s', IFD1OffsetPointer);\n\n\n    var thumbTags = readTags(dataView, tiffStart, tiffStart + IFD1OffsetPointer, IFD1Tags, bigEnd); // EXIF 2.3 specification for JPEG format thumbnail\n    // If the value of Compression(0x0103) Tag in IFD1 is '6', thumbnail image format is JPEG.\n    // Most of Exif image uses JPEG format for thumbnail. In that case, you can get offset of thumbnail\n    // by JpegIFOffset(0x0201) Tag in IFD1, size of thumbnail by JpegIFByteCount(0x0202) Tag.\n    // Data format is ordinary JPEG format, starts from 0xFFD8 and ends by 0xFFD9. It seems that\n    // JPEG format and 160x120pixels of size are recommended thumbnail format for Exif2.1 or later.\n\n    if (thumbTags['Compression']) {\n      // console.log('Thumbnail image found!');\n      switch (thumbTags['Compression']) {\n        case 6:\n          // console.log('Thumbnail image format is JPEG');\n          if (thumbTags.JpegIFOffset && thumbTags.JpegIFByteCount) {\n            // extract the thumbnail\n            var tOffset = tiffStart + thumbTags.JpegIFOffset;\n            var tLength = thumbTags.JpegIFByteCount;\n            thumbTags['blob'] = new Blob([new Uint8Array(dataView.buffer, tOffset, tLength)], {\n              type: 'image/jpeg'\n            });\n          }\n\n          break;\n\n        case 1:\n          console.log(\"Thumbnail image format is TIFF, which is not implemented.\");\n          break;\n\n        default:\n          console.log(\"Unknown thumbnail image format '%s'\", thumbTags['Compression']);\n      }\n    } else if (thumbTags['PhotometricInterpretation'] == 2) {\n      console.log(\"Thumbnail image format is RGB, which is not implemented.\");\n    }\n\n    return thumbTags;\n  }\n\n  function getStringFromDB(buffer, start, length) {\n    var outstr = \"\";\n\n    for (n = start; n < start + length; n++) {\n      outstr += String.fromCharCode(buffer.getUint8(n));\n    }\n\n    return outstr;\n  }\n\n  function readEXIFData(file, start) {\n    if (getStringFromDB(file, start, 4) != \"Exif\") {\n      if (debug) console.log(\"Not valid EXIF data! \" + getStringFromDB(file, start, 4));\n      return false;\n    }\n\n    var bigEnd,\n        tags,\n        tag,\n        exifData,\n        gpsData,\n        tiffOffset = start + 6; // test for TIFF validity and endianness\n\n    if (file.getUint16(tiffOffset) == 0x4949) {\n      bigEnd = false;\n    } else if (file.getUint16(tiffOffset) == 0x4D4D) {\n      bigEnd = true;\n    } else {\n      if (debug) console.log(\"Not valid TIFF data! (no 0x4949 or 0x4D4D)\");\n      return false;\n    }\n\n    if (file.getUint16(tiffOffset + 2, !bigEnd) != 0x002A) {\n      if (debug) console.log(\"Not valid TIFF data! (no 0x002A)\");\n      return false;\n    }\n\n    var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);\n\n    if (firstIFDOffset < 0x00000008) {\n      if (debug) console.log(\"Not valid TIFF data! (First offset less than 8)\", file.getUint32(tiffOffset + 4, !bigEnd));\n      return false;\n    }\n\n    tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, TiffTags, bigEnd);\n\n    if (tags.ExifIFDPointer) {\n      exifData = readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, ExifTags, bigEnd);\n\n      for (tag in exifData) {\n        switch (tag) {\n          case \"LightSource\":\n          case \"Flash\":\n          case \"MeteringMode\":\n          case \"ExposureProgram\":\n          case \"SensingMethod\":\n          case \"SceneCaptureType\":\n          case \"SceneType\":\n          case \"CustomRendered\":\n          case \"WhiteBalance\":\n          case \"GainControl\":\n          case \"Contrast\":\n          case \"Saturation\":\n          case \"Sharpness\":\n          case \"SubjectDistanceRange\":\n          case \"FileSource\":\n            exifData[tag] = StringValues[tag][exifData[tag]];\n            break;\n\n          case \"ExifVersion\":\n          case \"FlashpixVersion\":\n            exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);\n            break;\n\n          case \"ComponentsConfiguration\":\n            exifData[tag] = StringValues.Components[exifData[tag][0]] + StringValues.Components[exifData[tag][1]] + StringValues.Components[exifData[tag][2]] + StringValues.Components[exifData[tag][3]];\n            break;\n        }\n\n        tags[tag] = exifData[tag];\n      }\n    }\n\n    if (tags.GPSInfoIFDPointer) {\n      gpsData = readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, GPSTags, bigEnd);\n\n      for (tag in gpsData) {\n        switch (tag) {\n          case \"GPSVersionID\":\n            gpsData[tag] = gpsData[tag][0] + \".\" + gpsData[tag][1] + \".\" + gpsData[tag][2] + \".\" + gpsData[tag][3];\n            break;\n        }\n\n        tags[tag] = gpsData[tag];\n      }\n    } // extract thumbnail\n\n\n    tags['thumbnail'] = readThumbnailImage(file, tiffOffset, firstIFDOffset, bigEnd);\n    return tags;\n  }\n\n  function findXMPinJPEG(file) {\n    if (!('DOMParser' in self)) {\n      // console.warn('XML parsing not supported without DOMParser');\n      return;\n    }\n\n    var dataView = new DataView(file);\n    if (debug) console.log(\"Got file of length \" + file.byteLength);\n\n    if (dataView.getUint8(0) != 0xFF || dataView.getUint8(1) != 0xD8) {\n      if (debug) console.log(\"Not a valid JPEG\");\n      return false; // not a valid jpeg\n    }\n\n    var offset = 2,\n        length = file.byteLength,\n        dom = new DOMParser();\n\n    while (offset < length - 4) {\n      if (getStringFromDB(dataView, offset, 4) == \"http\") {\n        var startOffset = offset - 1;\n        var sectionLength = dataView.getUint16(offset - 2) - 1;\n        var xmpString = getStringFromDB(dataView, startOffset, sectionLength);\n        var xmpEndIndex = xmpString.indexOf('xmpmeta>') + 8;\n        xmpString = xmpString.substring(xmpString.indexOf('<x:xmpmeta'), xmpEndIndex);\n        var indexOfXmp = xmpString.indexOf('x:xmpmeta') + 10; //Many custom written programs embed xmp/xml without any namespace. Following are some of them.\n        //Without these namespaces, XML is thought to be invalid by parsers\n\n        xmpString = xmpString.slice(0, indexOfXmp) + 'xmlns:Iptc4xmpCore=\"http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/\" ' + 'xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ' + 'xmlns:tiff=\"http://ns.adobe.com/tiff/1.0/\" ' + 'xmlns:plus=\"http://schemas.android.com/apk/lib/com.google.android.gms.plus\" ' + 'xmlns:ext=\"http://www.gettyimages.com/xsltExtension/1.0\" ' + 'xmlns:exif=\"http://ns.adobe.com/exif/1.0/\" ' + 'xmlns:stEvt=\"http://ns.adobe.com/xap/1.0/sType/ResourceEvent#\" ' + 'xmlns:stRef=\"http://ns.adobe.com/xap/1.0/sType/ResourceRef#\" ' + 'xmlns:crs=\"http://ns.adobe.com/camera-raw-settings/1.0/\" ' + 'xmlns:xapGImg=\"http://ns.adobe.com/xap/1.0/g/img/\" ' + 'xmlns:Iptc4xmpExt=\"http://iptc.org/std/Iptc4xmpExt/2008-02-29/\" ' + xmpString.slice(indexOfXmp);\n        var domDocument = dom.parseFromString(xmpString, 'text/xml');\n        return xml2Object(domDocument);\n      } else {\n        offset++;\n      }\n    }\n  }\n\n  function xml2json(xml) {\n    var json = {};\n\n    if (xml.nodeType == 1) {\n      // element node\n      if (xml.attributes.length > 0) {\n        json['@attributes'] = {};\n\n        for (var j = 0; j < xml.attributes.length; j++) {\n          var attribute = xml.attributes.item(j);\n          json['@attributes'][attribute.nodeName] = attribute.nodeValue;\n        }\n      }\n    } else if (xml.nodeType == 3) {\n      // text node\n      return xml.nodeValue;\n    } // deal with children\n\n\n    if (xml.hasChildNodes()) {\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes.item(i);\n        var nodeName = child.nodeName;\n\n        if (json[nodeName] == null) {\n          json[nodeName] = xml2json(child);\n        } else {\n          if (json[nodeName].push == null) {\n            var old = json[nodeName];\n            json[nodeName] = [];\n            json[nodeName].push(old);\n          }\n\n          json[nodeName].push(xml2json(child));\n        }\n      }\n    }\n\n    return json;\n  }\n\n  function xml2Object(xml) {\n    try {\n      var obj = {};\n\n      if (xml.children.length > 0) {\n        for (var i = 0; i < xml.children.length; i++) {\n          var item = xml.children.item(i);\n          var attributes = item.attributes;\n\n          for (var idx in attributes) {\n            var itemAtt = attributes[idx];\n            var dataKey = itemAtt.nodeName;\n            var dataValue = itemAtt.nodeValue;\n\n            if (dataKey !== undefined) {\n              obj[dataKey] = dataValue;\n            }\n          }\n\n          var nodeName = item.nodeName;\n\n          if (typeof obj[nodeName] == \"undefined\") {\n            obj[nodeName] = xml2json(item);\n          } else {\n            if (typeof obj[nodeName].push == \"undefined\") {\n              var old = obj[nodeName];\n              obj[nodeName] = [];\n              obj[nodeName].push(old);\n            }\n\n            obj[nodeName].push(xml2json(item));\n          }\n        }\n      } else {\n        obj = xml.textContent;\n      }\n\n      return obj;\n    } catch (e) {\n      console.log(e.message);\n    }\n  }\n\n  EXIF.enableXmp = function () {\n    EXIF.isXmpEnabled = true;\n  };\n\n  EXIF.disableXmp = function () {\n    EXIF.isXmpEnabled = false;\n  };\n\n  EXIF.getData = function (img, callback) {\n    if ((self.Image && img instanceof self.Image || self.HTMLImageElement && img instanceof self.HTMLImageElement) && !img.complete) return false;\n\n    if (!imageHasData(img)) {\n      getImageData(img, callback);\n    } else {\n      if (callback) {\n        callback.call(img);\n      }\n    }\n\n    return true;\n  };\n\n  EXIF.getTag = function (img, tag) {\n    if (!imageHasData(img)) return;\n    return img.exifdata[tag];\n  };\n\n  EXIF.getIptcTag = function (img, tag) {\n    if (!imageHasData(img)) return;\n    return img.iptcdata[tag];\n  };\n\n  EXIF.getAllTags = function (img) {\n    if (!imageHasData(img)) return {};\n    var a,\n        data = img.exifdata,\n        tags = {};\n\n    for (a in data) {\n      if (data.hasOwnProperty(a)) {\n        tags[a] = data[a];\n      }\n    }\n\n    return tags;\n  };\n\n  EXIF.getAllIptcTags = function (img) {\n    if (!imageHasData(img)) return {};\n    var a,\n        data = img.iptcdata,\n        tags = {};\n\n    for (a in data) {\n      if (data.hasOwnProperty(a)) {\n        tags[a] = data[a];\n      }\n    }\n\n    return tags;\n  };\n\n  EXIF.pretty = function (img) {\n    if (!imageHasData(img)) return \"\";\n    var a,\n        data = img.exifdata,\n        strPretty = \"\";\n\n    for (a in data) {\n      if (data.hasOwnProperty(a)) {\n        if (typeof data[a] == \"object\") {\n          if (data[a] instanceof Number) {\n            strPretty += a + \" : \" + data[a] + \" [\" + data[a].numerator + \"/\" + data[a].denominator + \"]\\r\\n\";\n          } else {\n            strPretty += a + \" : [\" + data[a].length + \" values]\\r\\n\";\n          }\n        } else {\n          strPretty += a + \" : \" + data[a] + \"\\r\\n\";\n        }\n      }\n    }\n\n    return strPretty;\n  };\n\n  EXIF.readFromBinaryFile = function (file) {\n    return findEXIFinJPEG(file);\n  };\n\n  if (typeof define === 'function' && define.amd) {\n    define('exif-js', [], function () {\n      return EXIF;\n    });\n  }\n}).call(this);","map":{"version":3,"sources":["C:/workspace/nitgongsa/node_modules/exif-js/exif.js"],"names":["debug","root","EXIF","obj","EXIFwrapped","exports","module","ExifTags","Tags","TiffTags","GPSTags","IFD1Tags","StringValues","ExposureProgram","MeteringMode","LightSource","Flash","SensingMethod","SceneCaptureType","SceneType","CustomRendered","WhiteBalance","GainControl","Contrast","Saturation","Sharpness","SubjectDistanceRange","FileSource","Components","addEvent","element","event","handler","addEventListener","attachEvent","imageHasData","img","exifdata","base64ToArrayBuffer","base64","contentType","match","replace","binary","atob","len","length","buffer","ArrayBuffer","view","Uint8Array","i","charCodeAt","objectURLToBlob","url","callback","http","XMLHttpRequest","open","responseType","onload","e","status","response","send","getImageData","handleBinaryFile","binFile","data","findEXIFinJPEG","iptcdata","findIPTCinJPEG","isXmpEnabled","xmpdata","findXMPinJPEG","call","src","test","arrayBuffer","fileReader","FileReader","target","result","blob","readAsArrayBuffer","self","Blob","File","console","log","byteLength","file","dataView","DataView","getUint8","offset","marker","readEXIFData","getUint16","isFieldSegmentStart","nameHeaderLength","startOffset","sectionLength","readIPTCData","IptcFieldMap","fieldValue","fieldName","dataSize","segmentType","segmentSize","segmentStartPos","getInt16","getStringFromDB","hasOwnProperty","Array","push","readTags","tiffStart","dirStart","strings","bigEnd","entries","tags","entryOffset","tag","readTagValue","type","numValues","getUint32","valueOffset","vals","val","n","numerator","denominator","Number","getInt32","getNextIFDOffset","readThumbnailImage","firstIFDOffset","IFD1OffsetPointer","thumbTags","JpegIFOffset","JpegIFByteCount","tOffset","tLength","start","outstr","String","fromCharCode","exifData","gpsData","tiffOffset","ExifIFDPointer","GPSInfoIFDPointer","dom","DOMParser","xmpString","xmpEndIndex","indexOf","substring","indexOfXmp","slice","domDocument","parseFromString","xml2Object","xml2json","xml","json","nodeType","attributes","j","attribute","item","nodeName","nodeValue","hasChildNodes","childNodes","child","old","children","idx","itemAtt","dataKey","dataValue","undefined","textContent","message","enableXmp","disableXmp","getData","Image","HTMLImageElement","complete","getTag","getIptcTag","getAllTags","a","getAllIptcTags","pretty","strPretty","readFromBinaryFile","define","amd"],"mappings":"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","sourcesContent":["(function() {\r\n\r\n    var debug = false;\r\n\r\n    var root = this;\r\n\r\n    var EXIF = function(obj) {\r\n        if (obj instanceof EXIF) return obj;\r\n        if (!(this instanceof EXIF)) return new EXIF(obj);\r\n        this.EXIFwrapped = obj;\r\n    };\r\n\r\n    if (typeof exports !== 'undefined') {\r\n        if (typeof module !== 'undefined' && module.exports) {\r\n            exports = module.exports = EXIF;\r\n        }\r\n        exports.EXIF = EXIF;\r\n    } else {\r\n        root.EXIF = EXIF;\r\n    }\r\n\r\n    var ExifTags = EXIF.Tags = {\r\n\r\n        // version tags\r\n        0x9000 : \"ExifVersion\",             // EXIF version\r\n        0xA000 : \"FlashpixVersion\",         // Flashpix format version\r\n\r\n        // colorspace tags\r\n        0xA001 : \"ColorSpace\",              // Color space information tag\r\n\r\n        // image configuration\r\n        0xA002 : \"PixelXDimension\",         // Valid width of meaningful image\r\n        0xA003 : \"PixelYDimension\",         // Valid height of meaningful image\r\n        0x9101 : \"ComponentsConfiguration\", // Information about channels\r\n        0x9102 : \"CompressedBitsPerPixel\",  // Compressed bits per pixel\r\n\r\n        // user information\r\n        0x927C : \"MakerNote\",               // Any desired information written by the manufacturer\r\n        0x9286 : \"UserComment\",             // Comments by user\r\n\r\n        // related file\r\n        0xA004 : \"RelatedSoundFile\",        // Name of related sound file\r\n\r\n        // date and time\r\n        0x9003 : \"DateTimeOriginal\",        // Date and time when the original image was generated\r\n        0x9004 : \"DateTimeDigitized\",       // Date and time when the image was stored digitally\r\n        0x9290 : \"SubsecTime\",              // Fractions of seconds for DateTime\r\n        0x9291 : \"SubsecTimeOriginal\",      // Fractions of seconds for DateTimeOriginal\r\n        0x9292 : \"SubsecTimeDigitized\",     // Fractions of seconds for DateTimeDigitized\r\n\r\n        // picture-taking conditions\r\n        0x829A : \"ExposureTime\",            // Exposure time (in seconds)\r\n        0x829D : \"FNumber\",                 // F number\r\n        0x8822 : \"ExposureProgram\",         // Exposure program\r\n        0x8824 : \"SpectralSensitivity\",     // Spectral sensitivity\r\n        0x8827 : \"ISOSpeedRatings\",         // ISO speed rating\r\n        0x8828 : \"OECF\",                    // Optoelectric conversion factor\r\n        0x9201 : \"ShutterSpeedValue\",       // Shutter speed\r\n        0x9202 : \"ApertureValue\",           // Lens aperture\r\n        0x9203 : \"BrightnessValue\",         // Value of brightness\r\n        0x9204 : \"ExposureBias\",            // Exposure bias\r\n        0x9205 : \"MaxApertureValue\",        // Smallest F number of lens\r\n        0x9206 : \"SubjectDistance\",         // Distance to subject in meters\r\n        0x9207 : \"MeteringMode\",            // Metering mode\r\n        0x9208 : \"LightSource\",             // Kind of light source\r\n        0x9209 : \"Flash\",                   // Flash status\r\n        0x9214 : \"SubjectArea\",             // Location and area of main subject\r\n        0x920A : \"FocalLength\",             // Focal length of the lens in mm\r\n        0xA20B : \"FlashEnergy\",             // Strobe energy in BCPS\r\n        0xA20C : \"SpatialFrequencyResponse\",    //\r\n        0xA20E : \"FocalPlaneXResolution\",   // Number of pixels in width direction per FocalPlaneResolutionUnit\r\n        0xA20F : \"FocalPlaneYResolution\",   // Number of pixels in height direction per FocalPlaneResolutionUnit\r\n        0xA210 : \"FocalPlaneResolutionUnit\",    // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution\r\n        0xA214 : \"SubjectLocation\",         // Location of subject in image\r\n        0xA215 : \"ExposureIndex\",           // Exposure index selected on camera\r\n        0xA217 : \"SensingMethod\",           // Image sensor type\r\n        0xA300 : \"FileSource\",              // Image source (3 == DSC)\r\n        0xA301 : \"SceneType\",               // Scene type (1 == directly photographed)\r\n        0xA302 : \"CFAPattern\",              // Color filter array geometric pattern\r\n        0xA401 : \"CustomRendered\",          // Special processing\r\n        0xA402 : \"ExposureMode\",            // Exposure mode\r\n        0xA403 : \"WhiteBalance\",            // 1 = auto white balance, 2 = manual\r\n        0xA404 : \"DigitalZoomRation\",       // Digital zoom ratio\r\n        0xA405 : \"FocalLengthIn35mmFilm\",   // Equivalent foacl length assuming 35mm film camera (in mm)\r\n        0xA406 : \"SceneCaptureType\",        // Type of scene\r\n        0xA407 : \"GainControl\",             // Degree of overall image gain adjustment\r\n        0xA408 : \"Contrast\",                // Direction of contrast processing applied by camera\r\n        0xA409 : \"Saturation\",              // Direction of saturation processing applied by camera\r\n        0xA40A : \"Sharpness\",               // Direction of sharpness processing applied by camera\r\n        0xA40B : \"DeviceSettingDescription\",    //\r\n        0xA40C : \"SubjectDistanceRange\",    // Distance to subject\r\n\r\n        // other tags\r\n        0xA005 : \"InteroperabilityIFDPointer\",\r\n        0xA420 : \"ImageUniqueID\"            // Identifier assigned uniquely to each image\r\n    };\r\n\r\n    var TiffTags = EXIF.TiffTags = {\r\n        0x0100 : \"ImageWidth\",\r\n        0x0101 : \"ImageHeight\",\r\n        0x8769 : \"ExifIFDPointer\",\r\n        0x8825 : \"GPSInfoIFDPointer\",\r\n        0xA005 : \"InteroperabilityIFDPointer\",\r\n        0x0102 : \"BitsPerSample\",\r\n        0x0103 : \"Compression\",\r\n        0x0106 : \"PhotometricInterpretation\",\r\n        0x0112 : \"Orientation\",\r\n        0x0115 : \"SamplesPerPixel\",\r\n        0x011C : \"PlanarConfiguration\",\r\n        0x0212 : \"YCbCrSubSampling\",\r\n        0x0213 : \"YCbCrPositioning\",\r\n        0x011A : \"XResolution\",\r\n        0x011B : \"YResolution\",\r\n        0x0128 : \"ResolutionUnit\",\r\n        0x0111 : \"StripOffsets\",\r\n        0x0116 : \"RowsPerStrip\",\r\n        0x0117 : \"StripByteCounts\",\r\n        0x0201 : \"JPEGInterchangeFormat\",\r\n        0x0202 : \"JPEGInterchangeFormatLength\",\r\n        0x012D : \"TransferFunction\",\r\n        0x013E : \"WhitePoint\",\r\n        0x013F : \"PrimaryChromaticities\",\r\n        0x0211 : \"YCbCrCoefficients\",\r\n        0x0214 : \"ReferenceBlackWhite\",\r\n        0x0132 : \"DateTime\",\r\n        0x010E : \"ImageDescription\",\r\n        0x010F : \"Make\",\r\n        0x0110 : \"Model\",\r\n        0x0131 : \"Software\",\r\n        0x013B : \"Artist\",\r\n        0x8298 : \"Copyright\"\r\n    };\r\n\r\n    var GPSTags = EXIF.GPSTags = {\r\n        0x0000 : \"GPSVersionID\",\r\n        0x0001 : \"GPSLatitudeRef\",\r\n        0x0002 : \"GPSLatitude\",\r\n        0x0003 : \"GPSLongitudeRef\",\r\n        0x0004 : \"GPSLongitude\",\r\n        0x0005 : \"GPSAltitudeRef\",\r\n        0x0006 : \"GPSAltitude\",\r\n        0x0007 : \"GPSTimeStamp\",\r\n        0x0008 : \"GPSSatellites\",\r\n        0x0009 : \"GPSStatus\",\r\n        0x000A : \"GPSMeasureMode\",\r\n        0x000B : \"GPSDOP\",\r\n        0x000C : \"GPSSpeedRef\",\r\n        0x000D : \"GPSSpeed\",\r\n        0x000E : \"GPSTrackRef\",\r\n        0x000F : \"GPSTrack\",\r\n        0x0010 : \"GPSImgDirectionRef\",\r\n        0x0011 : \"GPSImgDirection\",\r\n        0x0012 : \"GPSMapDatum\",\r\n        0x0013 : \"GPSDestLatitudeRef\",\r\n        0x0014 : \"GPSDestLatitude\",\r\n        0x0015 : \"GPSDestLongitudeRef\",\r\n        0x0016 : \"GPSDestLongitude\",\r\n        0x0017 : \"GPSDestBearingRef\",\r\n        0x0018 : \"GPSDestBearing\",\r\n        0x0019 : \"GPSDestDistanceRef\",\r\n        0x001A : \"GPSDestDistance\",\r\n        0x001B : \"GPSProcessingMethod\",\r\n        0x001C : \"GPSAreaInformation\",\r\n        0x001D : \"GPSDateStamp\",\r\n        0x001E : \"GPSDifferential\"\r\n    };\r\n\r\n     // EXIF 2.3 Spec\r\n    var IFD1Tags = EXIF.IFD1Tags = {\r\n        0x0100: \"ImageWidth\",\r\n        0x0101: \"ImageHeight\",\r\n        0x0102: \"BitsPerSample\",\r\n        0x0103: \"Compression\",\r\n        0x0106: \"PhotometricInterpretation\",\r\n        0x0111: \"StripOffsets\",\r\n        0x0112: \"Orientation\",\r\n        0x0115: \"SamplesPerPixel\",\r\n        0x0116: \"RowsPerStrip\",\r\n        0x0117: \"StripByteCounts\",\r\n        0x011A: \"XResolution\",\r\n        0x011B: \"YResolution\",\r\n        0x011C: \"PlanarConfiguration\",\r\n        0x0128: \"ResolutionUnit\",\r\n        0x0201: \"JpegIFOffset\",    // When image format is JPEG, this value show offset to JPEG data stored.(aka \"ThumbnailOffset\" or \"JPEGInterchangeFormat\")\r\n        0x0202: \"JpegIFByteCount\", // When image format is JPEG, this value shows data size of JPEG image (aka \"ThumbnailLength\" or \"JPEGInterchangeFormatLength\")\r\n        0x0211: \"YCbCrCoefficients\",\r\n        0x0212: \"YCbCrSubSampling\",\r\n        0x0213: \"YCbCrPositioning\",\r\n        0x0214: \"ReferenceBlackWhite\"\r\n    };\r\n\r\n    var StringValues = EXIF.StringValues = {\r\n        ExposureProgram : {\r\n            0 : \"Not defined\",\r\n            1 : \"Manual\",\r\n            2 : \"Normal program\",\r\n            3 : \"Aperture priority\",\r\n            4 : \"Shutter priority\",\r\n            5 : \"Creative program\",\r\n            6 : \"Action program\",\r\n            7 : \"Portrait mode\",\r\n            8 : \"Landscape mode\"\r\n        },\r\n        MeteringMode : {\r\n            0 : \"Unknown\",\r\n            1 : \"Average\",\r\n            2 : \"CenterWeightedAverage\",\r\n            3 : \"Spot\",\r\n            4 : \"MultiSpot\",\r\n            5 : \"Pattern\",\r\n            6 : \"Partial\",\r\n            255 : \"Other\"\r\n        },\r\n        LightSource : {\r\n            0 : \"Unknown\",\r\n            1 : \"Daylight\",\r\n            2 : \"Fluorescent\",\r\n            3 : \"Tungsten (incandescent light)\",\r\n            4 : \"Flash\",\r\n            9 : \"Fine weather\",\r\n            10 : \"Cloudy weather\",\r\n            11 : \"Shade\",\r\n            12 : \"Daylight fluorescent (D 5700 - 7100K)\",\r\n            13 : \"Day white fluorescent (N 4600 - 5400K)\",\r\n            14 : \"Cool white fluorescent (W 3900 - 4500K)\",\r\n            15 : \"White fluorescent (WW 3200 - 3700K)\",\r\n            17 : \"Standard light A\",\r\n            18 : \"Standard light B\",\r\n            19 : \"Standard light C\",\r\n            20 : \"D55\",\r\n            21 : \"D65\",\r\n            22 : \"D75\",\r\n            23 : \"D50\",\r\n            24 : \"ISO studio tungsten\",\r\n            255 : \"Other\"\r\n        },\r\n        Flash : {\r\n            0x0000 : \"Flash did not fire\",\r\n            0x0001 : \"Flash fired\",\r\n            0x0005 : \"Strobe return light not detected\",\r\n            0x0007 : \"Strobe return light detected\",\r\n            0x0009 : \"Flash fired, compulsory flash mode\",\r\n            0x000D : \"Flash fired, compulsory flash mode, return light not detected\",\r\n            0x000F : \"Flash fired, compulsory flash mode, return light detected\",\r\n            0x0010 : \"Flash did not fire, compulsory flash mode\",\r\n            0x0018 : \"Flash did not fire, auto mode\",\r\n            0x0019 : \"Flash fired, auto mode\",\r\n            0x001D : \"Flash fired, auto mode, return light not detected\",\r\n            0x001F : \"Flash fired, auto mode, return light detected\",\r\n            0x0020 : \"No flash function\",\r\n            0x0041 : \"Flash fired, red-eye reduction mode\",\r\n            0x0045 : \"Flash fired, red-eye reduction mode, return light not detected\",\r\n            0x0047 : \"Flash fired, red-eye reduction mode, return light detected\",\r\n            0x0049 : \"Flash fired, compulsory flash mode, red-eye reduction mode\",\r\n            0x004D : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected\",\r\n            0x004F : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected\",\r\n            0x0059 : \"Flash fired, auto mode, red-eye reduction mode\",\r\n            0x005D : \"Flash fired, auto mode, return light not detected, red-eye reduction mode\",\r\n            0x005F : \"Flash fired, auto mode, return light detected, red-eye reduction mode\"\r\n        },\r\n        SensingMethod : {\r\n            1 : \"Not defined\",\r\n            2 : \"One-chip color area sensor\",\r\n            3 : \"Two-chip color area sensor\",\r\n            4 : \"Three-chip color area sensor\",\r\n            5 : \"Color sequential area sensor\",\r\n            7 : \"Trilinear sensor\",\r\n            8 : \"Color sequential linear sensor\"\r\n        },\r\n        SceneCaptureType : {\r\n            0 : \"Standard\",\r\n            1 : \"Landscape\",\r\n            2 : \"Portrait\",\r\n            3 : \"Night scene\"\r\n        },\r\n        SceneType : {\r\n            1 : \"Directly photographed\"\r\n        },\r\n        CustomRendered : {\r\n            0 : \"Normal process\",\r\n            1 : \"Custom process\"\r\n        },\r\n        WhiteBalance : {\r\n            0 : \"Auto white balance\",\r\n            1 : \"Manual white balance\"\r\n        },\r\n        GainControl : {\r\n            0 : \"None\",\r\n            1 : \"Low gain up\",\r\n            2 : \"High gain up\",\r\n            3 : \"Low gain down\",\r\n            4 : \"High gain down\"\r\n        },\r\n        Contrast : {\r\n            0 : \"Normal\",\r\n            1 : \"Soft\",\r\n            2 : \"Hard\"\r\n        },\r\n        Saturation : {\r\n            0 : \"Normal\",\r\n            1 : \"Low saturation\",\r\n            2 : \"High saturation\"\r\n        },\r\n        Sharpness : {\r\n            0 : \"Normal\",\r\n            1 : \"Soft\",\r\n            2 : \"Hard\"\r\n        },\r\n        SubjectDistanceRange : {\r\n            0 : \"Unknown\",\r\n            1 : \"Macro\",\r\n            2 : \"Close view\",\r\n            3 : \"Distant view\"\r\n        },\r\n        FileSource : {\r\n            3 : \"DSC\"\r\n        },\r\n\r\n        Components : {\r\n            0 : \"\",\r\n            1 : \"Y\",\r\n            2 : \"Cb\",\r\n            3 : \"Cr\",\r\n            4 : \"R\",\r\n            5 : \"G\",\r\n            6 : \"B\"\r\n        }\r\n    };\r\n\r\n    function addEvent(element, event, handler) {\r\n        if (element.addEventListener) {\r\n            element.addEventListener(event, handler, false);\r\n        } else if (element.attachEvent) {\r\n            element.attachEvent(\"on\" + event, handler);\r\n        }\r\n    }\r\n\r\n    function imageHasData(img) {\r\n        return !!(img.exifdata);\r\n    }\r\n\r\n\r\n    function base64ToArrayBuffer(base64, contentType) {\r\n        contentType = contentType || base64.match(/^data\\:([^\\;]+)\\;base64,/mi)[1] || ''; // e.g. 'data:image/jpeg;base64,...' => 'image/jpeg'\r\n        base64 = base64.replace(/^data\\:([^\\;]+)\\;base64,/gmi, '');\r\n        var binary = atob(base64);\r\n        var len = binary.length;\r\n        var buffer = new ArrayBuffer(len);\r\n        var view = new Uint8Array(buffer);\r\n        for (var i = 0; i < len; i++) {\r\n            view[i] = binary.charCodeAt(i);\r\n        }\r\n        return buffer;\r\n    }\r\n\r\n    function objectURLToBlob(url, callback) {\r\n        var http = new XMLHttpRequest();\r\n        http.open(\"GET\", url, true);\r\n        http.responseType = \"blob\";\r\n        http.onload = function(e) {\r\n            if (this.status == 200 || this.status === 0) {\r\n                callback(this.response);\r\n            }\r\n        };\r\n        http.send();\r\n    }\r\n\r\n    function getImageData(img, callback) {\r\n        function handleBinaryFile(binFile) {\r\n            var data = findEXIFinJPEG(binFile);\r\n            img.exifdata = data || {};\r\n            var iptcdata = findIPTCinJPEG(binFile);\r\n            img.iptcdata = iptcdata || {};\r\n            if (EXIF.isXmpEnabled) {\r\n               var xmpdata= findXMPinJPEG(binFile);\r\n               img.xmpdata = xmpdata || {};               \r\n            }\r\n            if (callback) {\r\n                callback.call(img);\r\n            }\r\n        }\r\n\r\n        if (img.src) {\r\n            if (/^data\\:/i.test(img.src)) { // Data URI\r\n                var arrayBuffer = base64ToArrayBuffer(img.src);\r\n                handleBinaryFile(arrayBuffer);\r\n\r\n            } else if (/^blob\\:/i.test(img.src)) { // Object URL\r\n                var fileReader = new FileReader();\r\n                fileReader.onload = function(e) {\r\n                    handleBinaryFile(e.target.result);\r\n                };\r\n                objectURLToBlob(img.src, function (blob) {\r\n                    fileReader.readAsArrayBuffer(blob);\r\n                });\r\n            } else {\r\n                var http = new XMLHttpRequest();\r\n                http.onload = function() {\r\n                    if (this.status == 200 || this.status === 0) {\r\n                        handleBinaryFile(http.response);\r\n                    } else {\r\n                        throw \"Could not load image\";\r\n                    }\r\n                    http = null;\r\n                };\r\n                http.open(\"GET\", img.src, true);\r\n                http.responseType = \"arraybuffer\";\r\n                http.send(null);\r\n            }\r\n        } else if (self.FileReader && (img instanceof self.Blob || img instanceof self.File)) {\r\n            var fileReader = new FileReader();\r\n            fileReader.onload = function(e) {\r\n                if (debug) console.log(\"Got file of length \" + e.target.result.byteLength);\r\n                handleBinaryFile(e.target.result);\r\n            };\r\n\r\n            fileReader.readAsArrayBuffer(img);\r\n        }\r\n    }\r\n\r\n    function findEXIFinJPEG(file) {\r\n        var dataView = new DataView(file);\r\n\r\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\r\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\r\n            if (debug) console.log(\"Not a valid JPEG\");\r\n            return false; // not a valid jpeg\r\n        }\r\n\r\n        var offset = 2,\r\n            length = file.byteLength,\r\n            marker;\r\n\r\n        while (offset < length) {\r\n            if (dataView.getUint8(offset) != 0xFF) {\r\n                if (debug) console.log(\"Not a valid marker at offset \" + offset + \", found: \" + dataView.getUint8(offset));\r\n                return false; // not a valid marker, something is wrong\r\n            }\r\n\r\n            marker = dataView.getUint8(offset + 1);\r\n            if (debug) console.log(marker);\r\n\r\n            // we could implement handling for other markers here,\r\n            // but we're only looking for 0xFFE1 for EXIF data\r\n\r\n            if (marker == 225) {\r\n                if (debug) console.log(\"Found 0xFFE1 marker\");\r\n\r\n                return readEXIFData(dataView, offset + 4, dataView.getUint16(offset + 2) - 2);\r\n\r\n                // offset += 2 + file.getShortAt(offset+2, true);\r\n\r\n            } else {\r\n                offset += 2 + dataView.getUint16(offset+2);\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function findIPTCinJPEG(file) {\r\n        var dataView = new DataView(file);\r\n\r\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\r\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\r\n            if (debug) console.log(\"Not a valid JPEG\");\r\n            return false; // not a valid jpeg\r\n        }\r\n\r\n        var offset = 2,\r\n            length = file.byteLength;\r\n\r\n\r\n        var isFieldSegmentStart = function(dataView, offset){\r\n            return (\r\n                dataView.getUint8(offset) === 0x38 &&\r\n                dataView.getUint8(offset+1) === 0x42 &&\r\n                dataView.getUint8(offset+2) === 0x49 &&\r\n                dataView.getUint8(offset+3) === 0x4D &&\r\n                dataView.getUint8(offset+4) === 0x04 &&\r\n                dataView.getUint8(offset+5) === 0x04\r\n            );\r\n        };\r\n\r\n        while (offset < length) {\r\n\r\n            if ( isFieldSegmentStart(dataView, offset )){\r\n\r\n                // Get the length of the name header (which is padded to an even number of bytes)\r\n                var nameHeaderLength = dataView.getUint8(offset+7);\r\n                if(nameHeaderLength % 2 !== 0) nameHeaderLength += 1;\r\n                // Check for pre photoshop 6 format\r\n                if(nameHeaderLength === 0) {\r\n                    // Always 4\r\n                    nameHeaderLength = 4;\r\n                }\r\n\r\n                var startOffset = offset + 8 + nameHeaderLength;\r\n                var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);\r\n\r\n                return readIPTCData(file, startOffset, sectionLength);\r\n\r\n                break;\r\n\r\n            }\r\n\r\n\r\n            // Not the marker, continue searching\r\n            offset++;\r\n\r\n        }\r\n\r\n    }\r\n    var IptcFieldMap = {\r\n        0x78 : 'caption',\r\n        0x6E : 'credit',\r\n        0x19 : 'keywords',\r\n        0x37 : 'dateCreated',\r\n        0x50 : 'byline',\r\n        0x55 : 'bylineTitle',\r\n        0x7A : 'captionWriter',\r\n        0x69 : 'headline',\r\n        0x74 : 'copyright',\r\n        0x0F : 'category'\r\n    };\r\n    function readIPTCData(file, startOffset, sectionLength){\r\n        var dataView = new DataView(file);\r\n        var data = {};\r\n        var fieldValue, fieldName, dataSize, segmentType, segmentSize;\r\n        var segmentStartPos = startOffset;\r\n        while(segmentStartPos < startOffset+sectionLength) {\r\n            if(dataView.getUint8(segmentStartPos) === 0x1C && dataView.getUint8(segmentStartPos+1) === 0x02){\r\n                segmentType = dataView.getUint8(segmentStartPos+2);\r\n                if(segmentType in IptcFieldMap) {\r\n                    dataSize = dataView.getInt16(segmentStartPos+3);\r\n                    segmentSize = dataSize + 5;\r\n                    fieldName = IptcFieldMap[segmentType];\r\n                    fieldValue = getStringFromDB(dataView, segmentStartPos+5, dataSize);\r\n                    // Check if we already stored a value with this name\r\n                    if(data.hasOwnProperty(fieldName)) {\r\n                        // Value already stored with this name, create multivalue field\r\n                        if(data[fieldName] instanceof Array) {\r\n                            data[fieldName].push(fieldValue);\r\n                        }\r\n                        else {\r\n                            data[fieldName] = [data[fieldName], fieldValue];\r\n                        }\r\n                    }\r\n                    else {\r\n                        data[fieldName] = fieldValue;\r\n                    }\r\n                }\r\n\r\n            }\r\n            segmentStartPos++;\r\n        }\r\n        return data;\r\n    }\r\n\r\n\r\n\r\n    function readTags(file, tiffStart, dirStart, strings, bigEnd) {\r\n        var entries = file.getUint16(dirStart, !bigEnd),\r\n            tags = {},\r\n            entryOffset, tag,\r\n            i;\r\n\r\n        for (i=0;i<entries;i++) {\r\n            entryOffset = dirStart + i*12 + 2;\r\n            tag = strings[file.getUint16(entryOffset, !bigEnd)];\r\n            if (!tag && debug) console.log(\"Unknown tag: \" + file.getUint16(entryOffset, !bigEnd));\r\n            tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);\r\n        }\r\n        return tags;\r\n    }\r\n\r\n\r\n    function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {\r\n        var type = file.getUint16(entryOffset+2, !bigEnd),\r\n            numValues = file.getUint32(entryOffset+4, !bigEnd),\r\n            valueOffset = file.getUint32(entryOffset+8, !bigEnd) + tiffStart,\r\n            offset,\r\n            vals, val, n,\r\n            numerator, denominator;\r\n\r\n        switch (type) {\r\n            case 1: // byte, 8-bit unsigned int\r\n            case 7: // undefined, 8-bit byte, value depending on field\r\n                if (numValues == 1) {\r\n                    return file.getUint8(entryOffset + 8, !bigEnd);\r\n                } else {\r\n                    offset = numValues > 4 ? valueOffset : (entryOffset + 8);\r\n                    vals = [];\r\n                    for (n=0;n<numValues;n++) {\r\n                        vals[n] = file.getUint8(offset + n);\r\n                    }\r\n                    return vals;\r\n                }\r\n\r\n            case 2: // ascii, 8-bit byte\r\n                offset = numValues > 4 ? valueOffset : (entryOffset + 8);\r\n                return getStringFromDB(file, offset, numValues-1);\r\n\r\n            case 3: // short, 16 bit int\r\n                if (numValues == 1) {\r\n                    return file.getUint16(entryOffset + 8, !bigEnd);\r\n                } else {\r\n                    offset = numValues > 2 ? valueOffset : (entryOffset + 8);\r\n                    vals = [];\r\n                    for (n=0;n<numValues;n++) {\r\n                        vals[n] = file.getUint16(offset + 2*n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n\r\n            case 4: // long, 32 bit int\r\n                if (numValues == 1) {\r\n                    return file.getUint32(entryOffset + 8, !bigEnd);\r\n                } else {\r\n                    vals = [];\r\n                    for (n=0;n<numValues;n++) {\r\n                        vals[n] = file.getUint32(valueOffset + 4*n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n\r\n            case 5:    // rational = two long values, first is numerator, second is denominator\r\n                if (numValues == 1) {\r\n                    numerator = file.getUint32(valueOffset, !bigEnd);\r\n                    denominator = file.getUint32(valueOffset+4, !bigEnd);\r\n                    val = new Number(numerator / denominator);\r\n                    val.numerator = numerator;\r\n                    val.denominator = denominator;\r\n                    return val;\r\n                } else {\r\n                    vals = [];\r\n                    for (n=0;n<numValues;n++) {\r\n                        numerator = file.getUint32(valueOffset + 8*n, !bigEnd);\r\n                        denominator = file.getUint32(valueOffset+4 + 8*n, !bigEnd);\r\n                        vals[n] = new Number(numerator / denominator);\r\n                        vals[n].numerator = numerator;\r\n                        vals[n].denominator = denominator;\r\n                    }\r\n                    return vals;\r\n                }\r\n\r\n            case 9: // slong, 32 bit signed int\r\n                if (numValues == 1) {\r\n                    return file.getInt32(entryOffset + 8, !bigEnd);\r\n                } else {\r\n                    vals = [];\r\n                    for (n=0;n<numValues;n++) {\r\n                        vals[n] = file.getInt32(valueOffset + 4*n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n\r\n            case 10: // signed rational, two slongs, first is numerator, second is denominator\r\n                if (numValues == 1) {\r\n                    return file.getInt32(valueOffset, !bigEnd) / file.getInt32(valueOffset+4, !bigEnd);\r\n                } else {\r\n                    vals = [];\r\n                    for (n=0;n<numValues;n++) {\r\n                        vals[n] = file.getInt32(valueOffset + 8*n, !bigEnd) / file.getInt32(valueOffset+4 + 8*n, !bigEnd);\r\n                    }\r\n                    return vals;\r\n                }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Given an IFD (Image File Directory) start offset\r\n    * returns an offset to next IFD or 0 if it's the last IFD.\r\n    */\r\n    function getNextIFDOffset(dataView, dirStart, bigEnd){\r\n        //the first 2bytes means the number of directory entries contains in this IFD\r\n        var entries = dataView.getUint16(dirStart, !bigEnd);\r\n\r\n        // After last directory entry, there is a 4bytes of data,\r\n        // it means an offset to next IFD.\r\n        // If its value is '0x00000000', it means this is the last IFD and there is no linked IFD.\r\n\r\n        return dataView.getUint32(dirStart + 2 + entries * 12, !bigEnd); // each entry is 12 bytes long\r\n    }\r\n\r\n    function readThumbnailImage(dataView, tiffStart, firstIFDOffset, bigEnd){\r\n        // get the IFD1 offset\r\n        var IFD1OffsetPointer = getNextIFDOffset(dataView, tiffStart+firstIFDOffset, bigEnd);\r\n\r\n        if (!IFD1OffsetPointer) {\r\n            // console.log('******** IFD1Offset is empty, image thumb not found ********');\r\n            return {};\r\n        }\r\n        else if (IFD1OffsetPointer > dataView.byteLength) { // this should not happen\r\n            // console.log('******** IFD1Offset is outside the bounds of the DataView ********');\r\n            return {};\r\n        }\r\n        // console.log('*******  thumbnail IFD offset (IFD1) is: %s', IFD1OffsetPointer);\r\n\r\n        var thumbTags = readTags(dataView, tiffStart, tiffStart + IFD1OffsetPointer, IFD1Tags, bigEnd)\r\n\r\n        // EXIF 2.3 specification for JPEG format thumbnail\r\n\r\n        // If the value of Compression(0x0103) Tag in IFD1 is '6', thumbnail image format is JPEG.\r\n        // Most of Exif image uses JPEG format for thumbnail. In that case, you can get offset of thumbnail\r\n        // by JpegIFOffset(0x0201) Tag in IFD1, size of thumbnail by JpegIFByteCount(0x0202) Tag.\r\n        // Data format is ordinary JPEG format, starts from 0xFFD8 and ends by 0xFFD9. It seems that\r\n        // JPEG format and 160x120pixels of size are recommended thumbnail format for Exif2.1 or later.\r\n\r\n        if (thumbTags['Compression']) {\r\n            // console.log('Thumbnail image found!');\r\n\r\n            switch (thumbTags['Compression']) {\r\n                case 6:\r\n                    // console.log('Thumbnail image format is JPEG');\r\n                    if (thumbTags.JpegIFOffset && thumbTags.JpegIFByteCount) {\r\n                    // extract the thumbnail\r\n                        var tOffset = tiffStart + thumbTags.JpegIFOffset;\r\n                        var tLength = thumbTags.JpegIFByteCount;\r\n                        thumbTags['blob'] = new Blob([new Uint8Array(dataView.buffer, tOffset, tLength)], {\r\n                            type: 'image/jpeg'\r\n                        });\r\n                    }\r\n                break;\r\n\r\n            case 1:\r\n                console.log(\"Thumbnail image format is TIFF, which is not implemented.\");\r\n                break;\r\n            default:\r\n                console.log(\"Unknown thumbnail image format '%s'\", thumbTags['Compression']);\r\n            }\r\n        }\r\n        else if (thumbTags['PhotometricInterpretation'] == 2) {\r\n            console.log(\"Thumbnail image format is RGB, which is not implemented.\");\r\n        }\r\n        return thumbTags;\r\n    }\r\n\r\n    function getStringFromDB(buffer, start, length) {\r\n        var outstr = \"\";\r\n        for (n = start; n < start+length; n++) {\r\n            outstr += String.fromCharCode(buffer.getUint8(n));\r\n        }\r\n        return outstr;\r\n    }\r\n\r\n    function readEXIFData(file, start) {\r\n        if (getStringFromDB(file, start, 4) != \"Exif\") {\r\n            if (debug) console.log(\"Not valid EXIF data! \" + getStringFromDB(file, start, 4));\r\n            return false;\r\n        }\r\n\r\n        var bigEnd,\r\n            tags, tag,\r\n            exifData, gpsData,\r\n            tiffOffset = start + 6;\r\n\r\n        // test for TIFF validity and endianness\r\n        if (file.getUint16(tiffOffset) == 0x4949) {\r\n            bigEnd = false;\r\n        } else if (file.getUint16(tiffOffset) == 0x4D4D) {\r\n            bigEnd = true;\r\n        } else {\r\n            if (debug) console.log(\"Not valid TIFF data! (no 0x4949 or 0x4D4D)\");\r\n            return false;\r\n        }\r\n\r\n        if (file.getUint16(tiffOffset+2, !bigEnd) != 0x002A) {\r\n            if (debug) console.log(\"Not valid TIFF data! (no 0x002A)\");\r\n            return false;\r\n        }\r\n\r\n        var firstIFDOffset = file.getUint32(tiffOffset+4, !bigEnd);\r\n\r\n        if (firstIFDOffset < 0x00000008) {\r\n            if (debug) console.log(\"Not valid TIFF data! (First offset less than 8)\", file.getUint32(tiffOffset+4, !bigEnd));\r\n            return false;\r\n        }\r\n\r\n        tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, TiffTags, bigEnd);\r\n\r\n        if (tags.ExifIFDPointer) {\r\n            exifData = readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, ExifTags, bigEnd);\r\n            for (tag in exifData) {\r\n                switch (tag) {\r\n                    case \"LightSource\" :\r\n                    case \"Flash\" :\r\n                    case \"MeteringMode\" :\r\n                    case \"ExposureProgram\" :\r\n                    case \"SensingMethod\" :\r\n                    case \"SceneCaptureType\" :\r\n                    case \"SceneType\" :\r\n                    case \"CustomRendered\" :\r\n                    case \"WhiteBalance\" :\r\n                    case \"GainControl\" :\r\n                    case \"Contrast\" :\r\n                    case \"Saturation\" :\r\n                    case \"Sharpness\" :\r\n                    case \"SubjectDistanceRange\" :\r\n                    case \"FileSource\" :\r\n                        exifData[tag] = StringValues[tag][exifData[tag]];\r\n                        break;\r\n\r\n                    case \"ExifVersion\" :\r\n                    case \"FlashpixVersion\" :\r\n                        exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);\r\n                        break;\r\n\r\n                    case \"ComponentsConfiguration\" :\r\n                        exifData[tag] =\r\n                            StringValues.Components[exifData[tag][0]] +\r\n                            StringValues.Components[exifData[tag][1]] +\r\n                            StringValues.Components[exifData[tag][2]] +\r\n                            StringValues.Components[exifData[tag][3]];\r\n                        break;\r\n                }\r\n                tags[tag] = exifData[tag];\r\n            }\r\n        }\r\n\r\n        if (tags.GPSInfoIFDPointer) {\r\n            gpsData = readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, GPSTags, bigEnd);\r\n            for (tag in gpsData) {\r\n                switch (tag) {\r\n                    case \"GPSVersionID\" :\r\n                        gpsData[tag] = gpsData[tag][0] +\r\n                            \".\" + gpsData[tag][1] +\r\n                            \".\" + gpsData[tag][2] +\r\n                            \".\" + gpsData[tag][3];\r\n                        break;\r\n                }\r\n                tags[tag] = gpsData[tag];\r\n            }\r\n        }\r\n\r\n        // extract thumbnail\r\n        tags['thumbnail'] = readThumbnailImage(file, tiffOffset, firstIFDOffset, bigEnd);\r\n\r\n        return tags;\r\n    }\r\n\r\n   function findXMPinJPEG(file) {\r\n\r\n        if (!('DOMParser' in self)) {\r\n            // console.warn('XML parsing not supported without DOMParser');\r\n            return;\r\n        }\r\n        var dataView = new DataView(file);\r\n\r\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\r\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\r\n           if (debug) console.log(\"Not a valid JPEG\");\r\n           return false; // not a valid jpeg\r\n        }\r\n\r\n        var offset = 2,\r\n            length = file.byteLength,\r\n            dom = new DOMParser();\r\n\r\n        while (offset < (length-4)) {\r\n            if (getStringFromDB(dataView, offset, 4) == \"http\") {\r\n                var startOffset = offset - 1;\r\n                var sectionLength = dataView.getUint16(offset - 2) - 1;\r\n                var xmpString = getStringFromDB(dataView, startOffset, sectionLength)\r\n                var xmpEndIndex = xmpString.indexOf('xmpmeta>') + 8;\r\n                xmpString = xmpString.substring( xmpString.indexOf( '<x:xmpmeta' ), xmpEndIndex );\r\n\r\n                var indexOfXmp = xmpString.indexOf('x:xmpmeta') + 10\r\n                //Many custom written programs embed xmp/xml without any namespace. Following are some of them.\r\n                //Without these namespaces, XML is thought to be invalid by parsers\r\n                xmpString = xmpString.slice(0, indexOfXmp)\r\n                            + 'xmlns:Iptc4xmpCore=\"http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/\" '\r\n                            + 'xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" '\r\n                            + 'xmlns:tiff=\"http://ns.adobe.com/tiff/1.0/\" '\r\n                            + 'xmlns:plus=\"http://schemas.android.com/apk/lib/com.google.android.gms.plus\" '\r\n                            + 'xmlns:ext=\"http://www.gettyimages.com/xsltExtension/1.0\" '\r\n                            + 'xmlns:exif=\"http://ns.adobe.com/exif/1.0/\" '\r\n                            + 'xmlns:stEvt=\"http://ns.adobe.com/xap/1.0/sType/ResourceEvent#\" '\r\n                            + 'xmlns:stRef=\"http://ns.adobe.com/xap/1.0/sType/ResourceRef#\" '\r\n                            + 'xmlns:crs=\"http://ns.adobe.com/camera-raw-settings/1.0/\" '\r\n                            + 'xmlns:xapGImg=\"http://ns.adobe.com/xap/1.0/g/img/\" '\r\n                            + 'xmlns:Iptc4xmpExt=\"http://iptc.org/std/Iptc4xmpExt/2008-02-29/\" '\r\n                            + xmpString.slice(indexOfXmp)\r\n\r\n                var domDocument = dom.parseFromString( xmpString, 'text/xml' );\r\n                return xml2Object(domDocument);\r\n            } else{\r\n             offset++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function xml2json(xml) {\r\n        var json = {};\r\n      \r\n        if (xml.nodeType == 1) { // element node\r\n          if (xml.attributes.length > 0) {\r\n            json['@attributes'] = {};\r\n            for (var j = 0; j < xml.attributes.length; j++) {\r\n              var attribute = xml.attributes.item(j);\r\n              json['@attributes'][attribute.nodeName] = attribute.nodeValue;\r\n            }\r\n          }\r\n        } else if (xml.nodeType == 3) { // text node\r\n          return xml.nodeValue;\r\n        }\r\n      \r\n        // deal with children\r\n        if (xml.hasChildNodes()) {\r\n          for(var i = 0; i < xml.childNodes.length; i++) {\r\n            var child = xml.childNodes.item(i);\r\n            var nodeName = child.nodeName;\r\n            if (json[nodeName] == null) {\r\n              json[nodeName] = xml2json(child);\r\n            } else {\r\n              if (json[nodeName].push == null) {\r\n                var old = json[nodeName];\r\n                json[nodeName] = [];\r\n                json[nodeName].push(old);\r\n              }\r\n              json[nodeName].push(xml2json(child));\r\n            }\r\n          }\r\n        }\r\n        \r\n        return json;\r\n    }\r\n\r\n    function xml2Object(xml) {\r\n        try {\r\n            var obj = {};\r\n            if (xml.children.length > 0) {\r\n              for (var i = 0; i < xml.children.length; i++) {\r\n                var item = xml.children.item(i);\r\n                var attributes = item.attributes;\r\n                for(var idx in attributes) {\r\n                    var itemAtt = attributes[idx];\r\n                    var dataKey = itemAtt.nodeName;\r\n                    var dataValue = itemAtt.nodeValue;\r\n\r\n                    if(dataKey !== undefined) {\r\n                        obj[dataKey] = dataValue;\r\n                    }\r\n                }\r\n                var nodeName = item.nodeName;\r\n\r\n                if (typeof (obj[nodeName]) == \"undefined\") {\r\n                  obj[nodeName] = xml2json(item);\r\n                } else {\r\n                  if (typeof (obj[nodeName].push) == \"undefined\") {\r\n                    var old = obj[nodeName];\r\n\r\n                    obj[nodeName] = [];\r\n                    obj[nodeName].push(old);\r\n                  }\r\n                  obj[nodeName].push(xml2json(item));\r\n                }\r\n              }\r\n            } else {\r\n              obj = xml.textContent;\r\n            }\r\n            return obj;\r\n          } catch (e) {\r\n              console.log(e.message);\r\n          }\r\n    }\r\n\r\n    EXIF.enableXmp = function() {\r\n        EXIF.isXmpEnabled = true;\r\n    }\r\n\r\n    EXIF.disableXmp = function() {\r\n        EXIF.isXmpEnabled = false;\r\n    }\r\n\r\n    EXIF.getData = function(img, callback) {\r\n        if (((self.Image && img instanceof self.Image)\r\n            || (self.HTMLImageElement && img instanceof self.HTMLImageElement))\r\n            && !img.complete)\r\n            return false;\r\n\r\n        if (!imageHasData(img)) {\r\n            getImageData(img, callback);\r\n        } else {\r\n            if (callback) {\r\n                callback.call(img);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    EXIF.getTag = function(img, tag) {\r\n        if (!imageHasData(img)) return;\r\n        return img.exifdata[tag];\r\n    }\r\n    \r\n    EXIF.getIptcTag = function(img, tag) {\r\n        if (!imageHasData(img)) return;\r\n        return img.iptcdata[tag];\r\n    }\r\n\r\n    EXIF.getAllTags = function(img) {\r\n        if (!imageHasData(img)) return {};\r\n        var a,\r\n            data = img.exifdata,\r\n            tags = {};\r\n        for (a in data) {\r\n            if (data.hasOwnProperty(a)) {\r\n                tags[a] = data[a];\r\n            }\r\n        }\r\n        return tags;\r\n    }\r\n    \r\n    EXIF.getAllIptcTags = function(img) {\r\n        if (!imageHasData(img)) return {};\r\n        var a,\r\n            data = img.iptcdata,\r\n            tags = {};\r\n        for (a in data) {\r\n            if (data.hasOwnProperty(a)) {\r\n                tags[a] = data[a];\r\n            }\r\n        }\r\n        return tags;\r\n    }\r\n\r\n    EXIF.pretty = function(img) {\r\n        if (!imageHasData(img)) return \"\";\r\n        var a,\r\n            data = img.exifdata,\r\n            strPretty = \"\";\r\n        for (a in data) {\r\n            if (data.hasOwnProperty(a)) {\r\n                if (typeof data[a] == \"object\") {\r\n                    if (data[a] instanceof Number) {\r\n                        strPretty += a + \" : \" + data[a] + \" [\" + data[a].numerator + \"/\" + data[a].denominator + \"]\\r\\n\";\r\n                    } else {\r\n                        strPretty += a + \" : [\" + data[a].length + \" values]\\r\\n\";\r\n                    }\r\n                } else {\r\n                    strPretty += a + \" : \" + data[a] + \"\\r\\n\";\r\n                }\r\n            }\r\n        }\r\n        return strPretty;\r\n    }\r\n\r\n    EXIF.readFromBinaryFile = function(file) {\r\n        return findEXIFinJPEG(file);\r\n    }\r\n\r\n    if (typeof define === 'function' && define.amd) {\r\n        define('exif-js', [], function() {\r\n            return EXIF;\r\n        });\r\n    }\r\n}.call(this));\r\n\r\n"]},"metadata":{},"sourceType":"script"}